const User = require('../Models/User');
const { generateToken } = require('../Helpers/jwtToken');
const { generateRefreshToken } = require('../Helpers/refreshToken');
const jwt = require('jsonwebtoken');
const validateMongoDbId = require('../Helpers/validateId');
const sendEmail = require('./NodeMailer');
const crypto = require('crypto');


const register = async (req, res) => {
    const searchEmail = req.body.email;
    const findEmail = await User.findOne({ email: searchEmail });

    if (!findEmail) {
        try {
            const { firstname, lastname, email, password } = req.body;
            const user = new User({
                firstname,
                lastname,
                email,
                password
            });
            await user.save();
            res.status(200).json({ message: "User registered successfully" });
        } catch (error) {
            console.error("Error registering user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    } else {
        return res.status(400).json({ message: "Email already in use" });
    }
}

// when logged in successfully it will generate a refresh token and token and send it to the user
// the refresh token will be saved in the cookies and the token will be sent in the response
// the token will be used to access the protected routes
// the refresh token will be used to refresh the token when it's expired
const login = async (req, res) => {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (user && (await user.isPasswordMatched(password))) {
        const refreshToken = generateRefreshToken(user?._id);
        const updateUser = await User.findByIdAndUpdate(user?._id, { refreshToken: refreshToken }, { new: true });
        res.cookie('refreshToken', refreshToken, {
            httpOnly: true,
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
        });

        res.status(200).json({
            message: "User logged in successfully",
            token: generateToken(user?._id)
        });
    } else {
        res.status(400).json({ message: "Invalid credentials" });
    }
}


// This function will be called when the user wants to refresh the token
// (the token is expired and the user wants to get a new token without login again)
// It will check if the refresh token is valid or not and if it's valid it will generate a refresh token
// and send it to the user
// if the refresh token not valid that means the refresh token is expired or not valid (not generated by the server)
const handleRefreshToken = async (req, res) => {
    const cookie = req.headers.cookie;
    let refreshToken;
    if (cookie) {
        const cookiesArray = cookie.split(';');
        for (const cookieItem of cookiesArray) {
            const [name, value] = cookieItem.trim().split('=');
            if (name === 'refreshToken') {
                refreshToken = value;
                break;
            }
        }
    }
    if (!refreshToken) {
        return res.status(401).json({ message: "Unauthorized, no refresh token in cookies!" });
    }
    try {
        const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_TOKEN_SECRET);
        const user = await User.findById(decoded.id);
        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }
        const accessToken = generateRefreshToken(user?._id);
        res.json({ accessToken });
    } catch (error) {
        console.error("Error refreshing token:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

// the cookie will be cleared and the refresh token will be removed from the database
// so the user will not be able to refresh the token again
const logout = async (req, res) => {
    const cookie = req.headers.cookie;
    let refreshToken;
    if (cookie) {
        const cookiesArray = cookie.split(';');
        for (const cookieItem of cookiesArray) {
            const [name, value] = cookieItem.trim().split('=');
            if (name === 'refreshToken') {
                refreshToken = value;
                break;
            }
        }
    }
    if (!refreshToken) {
        return res.status(400).json({ message: "No refresh token in cookies" });
    }
    try {
        const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_TOKEN_SECRET);
        const user = await User.findById(decoded.id);
        if (!user) {
            res.clearCookie('refreshToken', { httpOnly: true, secure: true });
            return res.status(404).json({ message: "User not found" });
        }
        await User.findByIdAndUpdate(user?._id, { refreshToken: '' });
        res.clearCookie('refreshToken', { httpOnly: true, secure: true });
        res.status(200).json({ message: "User logged out successfully" });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}


const deleteUser = async (req, res) => {
    try {
        const id = req.params.id;
        const user = await User.findById(id);

        if (!id) {
            return res.status(400).json({ message: 'User ID is required' });
        }
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }
        await User.findByIdAndDelete(id);
        res.status(200).json({ message: 'User deleted successfully' });
    } catch (error) {
        console.error('Error deleting user:', error);
        res.status(500).json({ message: 'Error deleting user' });
    }
}


const updatePassword = async (req, res) => {
    const { _id } = req.user;
    const { password } = req.body;
    validateMongoDbId(_id);
    const user = await User.findById(_id);
    if (password) {
        user.password = password;
        const updatedUser = await user.save();
        res.json(updatedUser);
    } else {
        res.json(user);
    }
}

const forgotPasswordToken = async (req, res) => {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
        return res.status(404).json({ message: "User not found" });
    } else {
        try {
            const token = await user.createPasswordResetToken();
            await user.save();

            const resetURL = `Hello ${user.firstname},
            \n\nPlease click on the link below to reset your password:
            \n\n${process.env.CLIENT_URL}/passwordReset/${token}
            \n\nIf you did not request this, please ignore this
            email and your password will remain unchanged.\n\nThanks,\nTeam Ons khiari`;

            const data = {
                to: user.email,
                subject: "Password reset",
                text: resetURL,
                html: resetURL
            };
            await sendEmail(data, req, res);
            res.status(200).json({ message: "Password reset token sent successfully" });
        } catch (error) {
            console.error('Error sending password reset token:', error);
            res.status(500).json({ message: 'Error sending password reset token' });
        }
    }

}

const resetPassword = async (req, res) => {
    const { password } = req.body;
    const resetToken = req.params.token;
    const resetPasswordToken = crypto.createHash('sha256').update(resetToken).digest('hex');
    const user = await User.findOne({
        passwordResetToken: resetPasswordToken,
        passwordResetExpire: { $gt: Date.now() }
    });

    if (!user) {
        return res.status(400).json({ message: "Invalid token" });
    }
    user.password = password;
    user.passwordResetToken = undefined;
    user.passwordResetExpire = undefined;
    await user.save();
    res.status(200).json({ message: "Password reset successfully" });
}


module.exports = {
    register,
    login,
    deleteUser,
    handleRefreshToken,
    logout,
    updatePassword,
    forgotPasswordToken,
    resetPassword
}